{"meta":{"title":"Jain的博客","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"idea快速上手指南","slug":"idea快速上手指南","date":"2020-05-25T00:35:46.721Z","updated":"2019-03-07T05:03:42.136Z","comments":true,"path":"2020/05/25/idea快速上手指南/","link":"","permalink":"http://yoursite.com/2020/05/25/idea%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/","excerpt":"","text":"Idea快速入门指南1.安装1.1.安装我们使用的是最新的2017.3.4版本： 双击打开， 选择一个目录，最好不要中文和空格： 然后选择桌面快捷方式，请选择64位： 然后选择安装： 开始安装： 然后勾选安装后运行，Finish： 1.2.首次配置 然后是UI界面选择，有白色和黑色两款，总有一款适合你： 把不需要的组件禁用： 插件暂时不选择安装，以后有需求还可以来安装： 然后进入运行界面： 激活Idea： 这里有三种激活方式： 第一种:购买正版用户(如果有资金最好选择正版) 第二种:激活码(这种方法在下面有讲解) 第三种:在线激活(有一个过期时间，这个时间一过就必须再次联网授权服务器请求激活) 土豪请选择第一种，每年大概不到$700 非土豪，请参考：http://idea.lanyus.com/ 中的教程。 激活完成，就可以开始撸代码了： 2.配置我们在启动界面打开配置页面： 进入idea以后，我们可以进行一系列配置。 2.1.字体和主题： 另外，主题也可以到网上下载，但是建议大家不要去浪费时间了。 2.2.启动项： 2.3.快捷键类名自动补全： 默认并不是Alt + /。而大家玩eclipse比较熟悉了，所以我们改成Alt + / 代码生成： 默认的代码生成快捷键：Alt + insert。很多同学电脑中没有 Insert 按键。 因此这里需要修改，大家自己选择。我设置的是Alt + I 还有快捷弹出 New菜单： 默认是Alt+Insert，没有Insert按键的同学，可以修改。我设置的也是Alt+ I 2.4.代码联想 2.5.编辑器字体： 2.6.编码 2.7.mavenidea自带的maven版本是3.3.9，我们一般不需要指定自己的。不过我们可以指定settings.xml来修改自己的仓库地址。 2.8.ES6语法支持 2.9.Vue插件安装 3.常用快捷键 快捷键 作用 Ctrl + Y 删除一行 Ctrl + D 复制一行 Ctrl + Alt + L 格式化 Ctrl + Alt + O 导包 Alt+Insert（可修改） New菜单\\代码生成菜单（生成getter和setter，maven依赖等） Ctrl + / 注释 Ctrl + Shift + / 多行注释 Ctrl + Alt + 左/右 回退到上一次操作的地方，等于eclipse中的 Alt+左/右 Shift + Alt + 上/下 将代码上移或下移一行 Ctry + H ：罗列类的继承关系 4.代码补全idea有很多的代码自动补全功能，有两个地方可以设置： 还有一个： 其作用演示： 通过后缀的方式快速完成一些代码的补全，一般写完后缀，按tab或回车即可。罗列一些比较常用的： 代码 效果 psvm 自动生成main函数 .var 自动为对象生成声明 sout 输出：System.out.println() .if 生成if判断 .for 生成循环，默认是高级for fori 用普通for进行遍历 .try 生成try … catch 5.project与module5.1.idea的maven理念在Idea中，没有工作空间的概念，每一个Project就是一个独立的文件夹，也是一个独立的窗口。然后我们可以在Project中创建多个Module。 是不是感觉与maven的项目结构完全一致？ 说对了，idea就是完全贯彻了maven的理念。 5.2.小技巧熟悉eclipse的同学会觉得很不方便，无法在一个界面中创建很多的工程。 不过有一个取巧的办法：我们可以创建一个empty的工程： 然后选择empty工程： 然后填写名称： 点击Finish： 但是接下来，就不要再新建Project了，而是新建Module，Module就类似原来的工程的概念： 然后创建一个maven工程： 然后填写项目信息： 填写项目位置信息： 界面结构： 6.打开springboot的run dashboard先看下run dashboard是什么： 可以看到，这里可以同时显示多个springboot项目，非常方便。 默认情况下，idea的run dashboard是关闭的，当检测到你有多个springboot项目时会弹出提示框，询问是否打开。 如果我们想要自己打开，需要修改配置。 在你的idea的项目目录中，有一个.idea目录： 其中，有一个workspace.xml： 打开，搜索Rundashboard，找到下面这段： 然后在Component中添加下面的内容： 12345&lt;option name=\"configurationTypes\"&gt; &lt;set&gt; &lt;option value=\"SpringBootApplicationConfigurationType\" /&gt; &lt;/set&gt; &lt;/option&gt;","categories":[],"tags":[]},{"title":"idea入门","slug":"idea入门","date":"2020-05-25T00:33:28.000Z","updated":"2020-05-25T00:37:37.844Z","comments":true,"path":"2020/05/25/idea入门/","link":"","permalink":"http://yoursite.com/2020/05/25/idea%E5%85%A5%E9%97%A8/","excerpt":"","text":"Idea快速入门指南1.安装1.1.安装我们使用的是最新的2017.3.4版本： 双击打开， 选择一个目录，最好不要中文和空格： 然后选择桌面快捷方式，请选择64位： 然后选择安装： 开始安装： 然后勾选安装后运行，Finish： 1.2.首次配置 然后是UI界面选择，有白色和黑色两款，总有一款适合你： 把不需要的组件禁用： 插件暂时不选择安装，以后有需求还可以来安装： 然后进入运行界面： 激活Idea： 这里有三种激活方式： 第一种:购买正版用户(如果有资金最好选择正版) 第二种:激活码(这种方法在下面有讲解) 第三种:在线激活(有一个过期时间，这个时间一过就必须再次联网授权服务器请求激活) 土豪请选择第一种，每年大概不到$700 非土豪，请参考：http://idea.lanyus.com/ 中的教程。 激活完成，就可以开始撸代码了： 2.配置我们在启动界面打开配置页面： 进入idea以后，我们可以进行一系列配置。 2.1.字体和主题： 另外，主题也可以到网上下载，但是建议大家不要去浪费时间了。 2.2.启动项： 2.3.快捷键类名自动补全： 默认并不是Alt + /。而大家玩eclipse比较熟悉了，所以我们改成Alt + / 代码生成： 默认的代码生成快捷键：Alt + insert。很多同学电脑中没有 Insert 按键。 因此这里需要修改，大家自己选择。我设置的是Alt + I 还有快捷弹出 New菜单： 默认是Alt+Insert，没有Insert按键的同学，可以修改。我设置的也是Alt+ I 2.4.代码联想 2.5.编辑器字体： 2.6.编码 2.7.mavenidea自带的maven版本是3.3.9，我们一般不需要指定自己的。不过我们可以指定settings.xml来修改自己的仓库地址。 2.8.ES6语法支持 2.9.Vue插件安装 3.常用快捷键 快捷键 作用 Ctrl + Y 删除一行 Ctrl + D 复制一行 Ctrl + Alt + L 格式化 Ctrl + Alt + O 导包 Alt+Insert（可修改） New菜单\\代码生成菜单（生成getter和setter，maven依赖等） Ctrl + / 注释 Ctrl + Shift + / 多行注释 Ctrl + Alt + 左/右 回退到上一次操作的地方，等于eclipse中的 Alt+左/右 Shift + Alt + 上/下 将代码上移或下移一行 Ctry + H ：罗列类的继承关系 4.代码补全idea有很多的代码自动补全功能，有两个地方可以设置： 还有一个： 其作用演示： 通过后缀的方式快速完成一些代码的补全，一般写完后缀，按tab或回车即可。罗列一些比较常用的： 代码 效果 psvm 自动生成main函数 .var 自动为对象生成声明 sout 输出：System.out.println() .if 生成if判断 .for 生成循环，默认是高级for fori 用普通for进行遍历 .try 生成try … catch 5.project与module5.1.idea的maven理念在Idea中，没有工作空间的概念，每一个Project就是一个独立的文件夹，也是一个独立的窗口。然后我们可以在Project中创建多个Module。 是不是感觉与maven的项目结构完全一致？ 说对了，idea就是完全贯彻了maven的理念。 5.2.小技巧熟悉eclipse的同学会觉得很不方便，无法在一个界面中创建很多的工程。 不过有一个取巧的办法：我们可以创建一个empty的工程： 然后选择empty工程： 然后填写名称： 点击Finish： 但是接下来，就不要再新建Project了，而是新建Module，Module就类似原来的工程的概念： 然后创建一个maven工程： 然后填写项目信息： 填写项目位置信息： 界面结构： 6.打开springboot的run dashboard先看下run dashboard是什么： 可以看到，这里可以同时显示多个springboot项目，非常方便。 默认情况下，idea的run dashboard是关闭的，当检测到你有多个springboot项目时会弹出提示框，询问是否打开。 如果我们想要自己打开，需要修改配置。 在你的idea的项目目录中，有一个.idea目录： 其中，有一个workspace.xml： 打开，搜索Rundashboard，找到下面这段： 然后在Component中添加下面的内容： 12345&lt;option name=\"configurationTypes\"&gt; &lt;set&gt; &lt;option value=\"SpringBootApplicationConfigurationType\" /&gt; &lt;/set&gt; &lt;/option&gt;","categories":[],"tags":[]},{"title":"centos7常用命令","slug":"centos7常用命令","date":"2020-05-18T08:58:41.000Z","updated":"2020-05-18T09:00:20.493Z","comments":true,"path":"2020/05/18/centos7常用命令/","link":"","permalink":"http://yoursite.com/2020/05/18/centos7%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"Linux - Centos意义：服务 目录结构： 目录名称 详细解析 备注 bin 存放普通用户可使用的命令文件 root用户也可使用 sbin 存放仅超级（root）用户可使用的命令文件 普通用户不可以使用 usr/bin 是从bin软连接过来 usr/sbin 是从sbin软连接过来 boot 存放系统启动的一些列文件，如grub，grub2等等 dev 系统的设备文件目录 如：硬盘，光驱等 etc 系统的配置文件目录 如：etc/rc,etc/sysconfig/network-scripts home 普通用户的家目录 如：使用useradd添加的普通用户，就存放在该目录下 lib 32位系统的库文件 很多命令都依赖库文件 lib64 64位系统的库文件 ，从CentOS7开始，Linux没有32位了 media 媒介目录 如插入u盘，会在该目录下显示 mnt 临时挂载的目录 可临时挂载光驱，新增硬盘等等 opt proc 系统启动的一些进程，每个进程都有一个pid，pid下，存放这进程的详细信息 ls -l /proc/281查看 root root用户的家目录 run 进程运行时产生的临时文件 重启后，文件就会消失 srv service服务产生的文件 sys 系统内核相关的文件 平时不会动里面的东西 tmp 系统的临时文件目录，权限很大，任何用户都可以访问 usr Unix System Resource，并不是user的缩写 后面一些常见的服务，apache，mysql等服务，会放在usr/local下 var 某些大文件的溢出区，比方说各种服务的日志文件 var/log/message，存放系统日志文件 常见命令：主提示符 ​ [用户@主机名 工作目录] 辅助提示符 ​ #：管理员 ​ $：普通用户 pwd： ​ 用途：查看当前工作目录 cd ： ​ 用途：转到指定文件夹 ls： ​ 用途：罗列出所有当前目录下的所有文件夹 ​ 格式：ls [选项] ​ 选项： ​ -l ：显示文件的详细信息（可以简写”ll”） ​ -R： ​ -a：显示当前文件夹的所有文件包括隐藏文件 ​ -h：格式化显示文件信息 mkdir： ​ 用途：创建目录 rmdir： ​ 用途：删除目录 touch： ​ 用途：创建文件 rm： ​ 用途：删除文件 ​ 选项： ​ -r：删除文件夹 ​ -f：强制删除 vi： ​ 用途：编辑文件 cat： ​ 用途：查看文件","categories":[],"tags":[{"name":"centos7","slug":"centos7","permalink":"http://yoursite.com/tags/centos7/"}]},{"title":"redis5单机多节点集群","slug":"redis5单机多节点集群","date":"2020-05-13T16:09:54.000Z","updated":"2020-05-14T02:20:37.884Z","comments":true,"path":"2020/05/14/redis5单机多节点集群/","link":"","permalink":"http://yoursite.com/2020/05/14/redis5%E5%8D%95%E6%9C%BA%E5%A4%9A%E8%8A%82%E7%82%B9%E9%9B%86%E7%BE%A4/","excerpt":"","text":"根目录创建文件夹 1mkdir redis_cluster 进入 redis_cluster 分别创建6个文件夹 1mkdir 7001 7002 7003 7004 7005 7006 从前面安装的redis文件夹中拷贝一份redis.conf到7001文件夹 1cp redis-5.0.8&#x2F;redis.conf &#x2F;root&#x2F;redis_cluster&#x2F;7001 修改 12345678port 7001 #端口cluster-enabled yes #启用集群模式cluster-config-file nodes_7001.confcluster-node-timeout 5000 #超时时间appendonly yesdaemonize yes #后台运行protected-mode no #非保护模式pidfile &#x2F;var&#x2F;run&#x2F;redis_7001.pid 再复制到 7002-7006分别修改port,cluster-config,pidfile为7002-7006 完事了之后，依次启动redis服务 123456&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-server &#x2F;root&#x2F;redis_cluster&#x2F;7001&#x2F;redis.conf&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-server &#x2F;root&#x2F;redis_cluster&#x2F;7002&#x2F;redis.conf&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-server &#x2F;root&#x2F;redis_cluster&#x2F;7003&#x2F;redis.conf&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-server &#x2F;root&#x2F;redis_cluster&#x2F;7004&#x2F;redis.conf&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-server &#x2F;root&#x2F;redis_cluster&#x2F;7005&#x2F;redis.conf&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-server &#x2F;root&#x2F;redis_cluster&#x2F;7006&#x2F;redis.conf 查看是否启动成功 1ps -ef | grep redis 启动之后就可以集群了（Redis5之后直接用redis自带的redis-cli就可以了，redis3-4需要安装ruby脚本） 1&#x2F;root&#x2F;redis-5.0.8&#x2F;src&#x2F;redis-cli --cluster create 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 127.0.0.1:7006 --cluster-replicas 1 期间会询问你是否同意redis的主从模式的建议输入yes即可","categories":[],"tags":[]},{"title":"'centos7安装jdk1.8'","slug":"centos7安装jdk1.8","date":"2020-05-13T15:02:04.000Z","updated":"2020-05-14T01:38:59.260Z","comments":true,"path":"2020/05/13/centos7安装jdk1.8/","link":"","permalink":"http://yoursite.com/2020/05/13/centos7%E5%AE%89%E8%A3%85jdk1.8/","excerpt":"","text":"先去java官网下载linux上的java安装包 后缀名为tar.gz的https://www.oracle.com/java/technologies/javase-jre8-downloads.html#license-lightbox在/home/data文件夹下创建一个java文件夹用来存放java文件如果没有data文件夹就新建一个新建好了之后，再通过fpt软件将之前下载好的java压缩包传到java文件夹解压压缩包：tar -zxvf jdk-8u231-linux-x64.tar.gz解压之后可以删除压缩包：rm -rf jdk-8u231-linux-x64.tar.gz输入 /vi/profile 再最后一行加入以下配置按i编辑export JAVA_HOME=/home/data/javaexport JRE_HOME=/home/data/java/jdk1.8.0_231export CLASSPATH=$JRE_HOME/lib/dt.jar:$JRE_HOME/lib/extexport PATH=$PATH:CLASSPATH:$JRE_HOME/bin:wq 保存并退出source /vi/profile：使配置文件生效然后分别输入 java -versionjavajavac没报错就是安装完成","categories":[],"tags":[{"name":"centos7","slug":"centos7","permalink":"http://yoursite.com/tags/centos7/"}]},{"title":"关机和重启'","slug":"关机和重启","date":"2020-05-13T15:02:04.000Z","updated":"2020-05-14T02:19:57.253Z","comments":true,"path":"2020/05/13/关机和重启/","link":"","permalink":"http://yoursite.com/2020/05/13/%E5%85%B3%E6%9C%BA%E5%92%8C%E9%87%8D%E5%90%AF/","excerpt":"","text":"关机和重启显示系统当前时间：dateshutdown [选项] 时间-c ：取消上一个关机命令-h ：关机-r： 重启时间为now代表立即","categories":[],"tags":[{"name":"centos7","slug":"centos7","permalink":"http://yoursite.com/tags/centos7/"}]},{"title":"' grep命令 '","slug":"grep命令","date":"2020-05-13T15:02:04.000Z","updated":"2020-05-14T01:36:27.396Z","comments":true,"path":"2020/05/13/grep命令/","link":"","permalink":"http://yoursite.com/2020/05/13/grep%E5%91%BD%E4%BB%A4/","excerpt":"","text":"grep搜索在vi编辑器里面搜索:/[关键字]下一个：n上一个：shift+n搜索文件里面的内容grep -v -i [关键字] [目录]排除关键字：-v不区分大小写：-i 命令搜索命令：搜索命令的目录：whereis [命令名]查找可执行文件的未知：-b查找帮助文件的未知：-m 搜索命令所在路径以及别名：which [命令名]","categories":[],"tags":[{"name":"测试","slug":"测试","permalink":"http://yoursite.com/tags/%E6%B5%8B%E8%AF%95/"}]},{"title":"'压缩和解压'","slug":"压缩和解压","date":"2020-05-13T15:02:04.000Z","updated":"2020-05-14T01:38:21.131Z","comments":true,"path":"2020/05/13/压缩和解压/","link":"","permalink":"http://yoursite.com/2020/05/13/%E5%8E%8B%E7%BC%A9%E5%92%8C%E8%A7%A3%E5%8E%8B/","excerpt":"","text":"zipzip格式压缩：在压缩之前先在我们终端安装压缩工具yum -y install zip 压缩：zip [压缩后的文件名] [源文件]压缩目录：zip -r [压缩后的文件名] [源文件] zip格式解压： 解压命令也需要安装工具yum -y install unzip 解压文件：unzip [文件名] gzgz格式压缩 ： 压缩（默认名为源文件加gz，压缩之后源文件会消失）：gzip [源文件]压缩2（保留源文件）：gizp -c [源文件] &gt; [压缩后的文件名]压缩目录（目录不能压缩，但是会压缩目录里面的文件）：gzip -r [源文件] gz格式解压： 解压1：gzip -d [压缩文件]解压2：gunzip [压缩文件] bz2 bz2格式压缩： 压缩前先装bzip2 ： yum -y install bzip2 压缩： bzip2 [源文件] ； 解压保留文件：bizp2 -k [源文件]bz2格式解压： 解压： bzip2 -d [源文件] ； 解压保留源文件： bzip2 -dk [源文件] tar-c：打包-v：显示过程-f：指定打包后的文件名-z：打包成tar.gz的格式-j：打包成tar.bz2的格式 tar打包： tar -cvf [打包后的文件名] 源文件 一次性打包成tar.gz：tar -zcvf [打包后的文件名] [源文件] 一次性打包成tar.bz2：tar -jcvf [打包后的文件名] [源文件]tar解打包： tar -xvf [源文件] 一次解打包成tar.gz：tar -zxvf [文件] 一次解打包成tar.gz：tar -zxvf [文件] 解压tar文件到指定目录tar -zxvf a.tar.gz -C /tmp压缩多个文件到指定目录tar -zcvf /tmp/test.tar.gz a b c查看tar文件tar -ztvf a.tar.gz","categories":[],"tags":[{"name":"centos7","slug":"centos7","permalink":"http://yoursite.com/tags/centos7/"}]},{"title":"' ll命令详解 '","slug":"ll命令详解","date":"2020-05-13T15:02:04.000Z","updated":"2020-05-14T01:37:28.375Z","comments":true,"path":"2020/05/13/ll命令详解/","link":"","permalink":"http://yoursite.com/2020/05/13/ll%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"一、ll命令 ll并不是linux下一个基本的命令，它实际上是ls -l的一个别名。Ubuntu默认不支持命令ll，必须用 ls -l，这样使用起来不是很方便。如果要使用此命令，可以作如下修改：打开 /.bashrc找到 #alias ll=’ls -l’，去掉前面的#就可以了。（关闭原来的终端才能使命令生效）这样个人用户可以使用ll命令，当切换成超级用户后，使用ll命令时提示找不到命令，那是因为你只是修改了个人用户的配置，所以，切换成root后做相同的操作即可解决问题。启示：我们可以通过修改/.bashrc添加任何其他的命令别名。 二、ll命令结果说明drwxr-xr-x 2 root root 48 2013-11-27 16:34 test/第一个栏位，表示文件的属性。Linux的文件基本上分为三个属性：可读（r），可写（w），可执行（x）。这里有十个格子可以添（具体程序实现时，实际上是十个bit位）。 第一个字母表示文件类型, ”-”,普通文件. ”d”目录,字母”d”,是dirtectory(目录)的缩写. “l”符号链接。请注意,一个目录或者说一个文件夹是一个特殊文件,这个特殊文件存放的是其他文件和文件夹的相关信息. “b”块设备文件。 “c”字符设备文件。紧接着的3*3个字符分3组，各指示此文件的读、写、执行权限，对于owner、group、others而言。因为Linux是多用户多任务系统，所以一个文件可能同时被许多人使用，所以我们一定要设好每个文件的权限，其文件的权限位置排列顺序是（以-rwxr-xr-x为例）： rwx(Owner)r-x(Group)r-x(Other) 这个例子表示的权限是：使用者自己可读，可写，可执行；同一组的用户可读，不可写，可执行；其它用户可读，不可写，可执行。另外，有一些程序属性的执行部分不是X,而是S,这表示执行这个程序的使用者，临时可以有和拥有者一样权力的身份来执行该程序。一般出现在系统管理之类的指令或程序，让使用者执行时，拥有root身份。 第二个栏位，表示文件个数。如果是文件的话，那这个数目自然是1了，如果是目录的话，那它的数目就是该目录中的文件个数了。第三个栏位，表示该文件或目录的拥有者。若使用者目前处于自己的Home,那这一栏大概都是它的账号名称。第四个栏位，表示所属的组（group）。每一个使用者都可以拥有一个以上的组，不过大部分的使用者应该都只属于一个组，只有当系统管理员希望给予某使用者特殊权限时，才可能会给他另一个组。第五栏位，表示文件大小。文件大小用byte来表示，而空目录一般都是1024byte，当然可以用其它参数使文件显示的单位不同，如使用ls –k就是用kb莱显示一个文件的大小单位，不过一般我们还是以byte为主。 第六个栏位，表示最后一次修改时间。以“月，日，时间”的格式表示，如Aug 15 5:46表示8月15日早上5:46分。第七个栏位，表示文件名。我们可以用ls –a显示隐藏的文件名。修改文件权限用，chmod命令常用的linux文件权限：444 r–r–r–600 rw——-644 rw-r–r–666 rw-rw-rw-700 rwx——744 rwxr–r–755 rwxr-xr-x777 rwxrwxrwx从左至右，1-3位数字代表文件所有者的权限，4-6位数字代表同组用户的权限，7-9数字代表其他用户的权限。而具体的权限是由数字来表示的，读取的权限等于4，用r表示；写入的权限等于2，用w表示；执行的权限等于1，用x表示；通过4、2、1的组合，得到以下几种权限：0（没有权限）；4（读取权限）；5（4+1 | 读取+执行）；6（4+2 | 读取+写入）；7（4+2+1 | 读取+写入+执行）以755为例：","categories":[],"tags":[{"name":"测试","slug":"测试","permalink":"http://yoursite.com/tags/%E6%B5%8B%E8%AF%95/"}]},{"title":"'文件操作'","slug":"文件操作","date":"2020-05-13T15:02:04.000Z","updated":"2020-05-14T01:30:49.645Z","comments":true,"path":"2020/05/13/文件操作/","link":"","permalink":"http://yoursite.com/2020/05/13/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/","excerpt":"","text":"创建删除文件：1234567mkdir 文件名 ： 创建文件夹mkdir -p ：递归创建文件夹touch : 创建文件rmdir：删除文件夹（不常用）rm -rf：强制删除文件和目录-r ：删除目录-f ：强制删除，不需要询问 复制文件：12345cp [选项] [源文件目录] [目标目录]-r：复制文件夹-p：连带属性一起复制-d：若源文件是链接文件，则复制链接属性-a：相当于 -pdr 剪切文件和重命名：1mv[源文件目录][目标目录]","categories":[],"tags":[{"name":"centos7","slug":"centos7","permalink":"http://yoursite.com/tags/centos7/"}]},{"title":"'搜索命令'","slug":"搜索命令","date":"2020-05-13T15:02:04.000Z","updated":"2020-05-14T01:35:19.520Z","comments":true,"path":"2020/05/13/搜索命令/","link":"","permalink":"http://yoursite.com/2020/05/13/%E6%90%9C%E7%B4%A2%E5%91%BD%E4%BB%A4/","excerpt":"","text":"locate搜索：首先要在yum上安装locate命令行输入yum -y install mlocate安装成功后输入updatedb 刷新底层数据库locate默认不会搜索临时目录的文件配置文件目录为：/etc/updatedb.cfg使用：locate [关键字] find命令：find [目录] -name [文件名] ：精确搜索find [目录] -iname [文件名] ：不区分大小写的搜索find [目录] -name “?关[键贱]字*” ：模糊搜索（关键字要用引号引起来）find [目录] -user [用户名] ：搜索某个用户下在某个文件夹下所有的文件包括隐藏文件find [目录] -mtime [Day]/[-Day]/[+Day]：Day天/ Day天之前/ Day天之后的文件find [目录] -size [Size]/[-Size]/[+Size]：Size(KB)/小于Size(KB)/大于Size(KB)的文件find [目录] -inum [inum] ：搜索某个目录下i节点为inum的文件find [目录] -size +20k -a -size -50k ： 搜索某个目录下大于20kb 小于 50kb的find [目录] -size +20k -a -size -50k -exec ls -lh {} ; 搜索某个目录下大于20kb 小于 50kb的后罗列出详细信息 逻辑运算符：-a：and 并且 同时满足为真-o：or 一边满足为真通配符：*：匹配任意字符?：匹配任意一个字符[abc]：匹配中括号中任意一个字符","categories":[],"tags":[{"name":"测试","slug":"测试","permalink":"http://yoursite.com/tags/%E6%B5%8B%E8%AF%95/"}]},{"title":"'目录介绍'","slug":"目录介绍","date":"2020-05-13T15:02:04.000Z","updated":"2020-05-14T01:33:23.650Z","comments":true,"path":"2020/05/13/目录介绍/","link":"","permalink":"http://yoursite.com/2020/05/13/%E7%9B%AE%E5%BD%95%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"基本目录介绍/boot目录，是启动目录存的是启动相关的文件该目录下不要乱存东西/dev设备文件保存目录/etc配置文件保存目录/home普通用户的目录/lib系统库保存目录/mnt系统挂载目录/media挂载目录/root超级用户的目录/proc直接写入内存的，虚拟文件系统/sys直接写入内存的，虚拟文件系统/var系统相关文档内容ls：显示当前目录下的和文件和目录ls -a：显示当前目录下包括隐藏的的和文件和目录ls -l ： 显示当前目录下的文件和目录的详细信息（可以简化为”ll“）ls -li：显示目录idls-lh：人性化显示（内存，日期格式化）","categories":[],"tags":[{"name":"centos7","slug":"centos7","permalink":"http://yoursite.com/tags/centos7/"}]},{"title":"centos7安装tomcat8","slug":"centos7安装tomcat8","date":"2020-05-13T15:02:04.000Z","updated":"2020-05-14T01:40:33.870Z","comments":true,"path":"2020/05/13/centos7安装tomcat8/","link":"","permalink":"http://yoursite.com/2020/05/13/centos7%E5%AE%89%E8%A3%85tomcat8/","excerpt":"","text":"创建 /home/data/tomcat文件夹去官网下载tomcat8.tar.gz的压缩包通过fpt传送到tomcat文件夹tar -zxvf 文件名修改默认端口号解压之后打开解压后的文件夹/conf/server.xml搜索/&lt;Connector port=”8080”修改8080为80注意！修改的是注释外的内容保存退出 :wq放通80端口firewall-cmd –zone=public –add-port=80/tcp -permanentfireewall-cmd –reload 在本地访问 http//ip如果显示tomcat首页代表安装成功","categories":[],"tags":[{"name":"centos7","slug":"centos7","permalink":"http://yoursite.com/tags/centos7/"}]},{"title":"centos7安装mysql5.7","slug":"centos7安装mysql5.7","date":"2020-05-13T15:02:04.000Z","updated":"2020-05-14T01:39:53.396Z","comments":true,"path":"2020/05/13/centos7安装mysql5.7/","link":"","permalink":"http://yoursite.com/2020/05/13/centos7%E5%AE%89%E8%A3%85mysql5.7/","excerpt":"","text":"先创建文件夹 /home/data/mysqlhttps://mirror.tuna.tsinghua.edu.cn/mysql/downloads/MySQL-5.7/mysql-5.7.28-1.el7.x86_64.rpm-bundle.tar下载到mysql文件夹解压：tar -xv mysql-5.7.28-1.el7.x86_64.rpm-bundle.tarls 会由几个tar的rpm -qa | grep mysql ：如果有信息 rm -rf rpm -qa | grep mysql主要安装的是这4个mysql-community-common-5.7.28-1.el7.x86_64mysql-community-client-5.7.28-1.el7.x86_64mysql-community-libs-5.7.28-1.el7.x86_64mysql-community-server-5.7.28-1.el7.x86_64rpm -ivh 文件名如果有报错再命令后面加上 –force –nodeps启动mysql服务systemctl start mysqld安装之后mysql的密码是随机的我们要去mysql日志文件去找cat /var/log/mysqld.log | grep password)红框的是密码mysql -uroot -p 输入密码登陆成功之后我们需要更改密码alter user ‘root’@’lcoalhost’ identified by ‘123456’;如果报错是因为：在 mysql 5.7之后密码需要安全验证不能太过于简单我们可以通过修改配置文件而将安全验证取消先退出mysql ：exitvi /etc/my.cnf[mysqld] 这一行下面加上validate_password=off:wq保存并退出重启mysql服务systemctl restart mysqld然后登陆mysqlmysql -uroot -p123456登陆成功之后就可以修改密码了alter user ‘root’@’lcoalhost’ identified by ‘123456’;远程连接mysqlgrant all privileges on . to root@”%” identified by “password”;flush privileges;表示：用户名为root密码为password的用户 允许在任意ip连接数据库放通3306端口firewall-cmd –zone=public –add-port=3306/tcp –permanentfirewall-cmd –reload接下来就可以连接了","categories":[],"tags":[{"name":"centos7","slug":"centos7","permalink":"http://yoursite.com/tags/centos7/"}]},{"title":"SpringBoot入门","slug":"SpringBoot入门","date":"2020-05-13T15:02:04.000Z","updated":"2020-05-25T00:31:26.453Z","comments":true,"path":"2020/05/13/SpringBoot入门/","link":"","permalink":"http://yoursite.com/2020/05/13/SpringBoot%E5%85%A5%E9%97%A8/","excerpt":"","text":"0.学习目标 了解SpringBoot的作用 掌握java配置的方式 了解SpringBoot自动配置原理 掌握SpringBoot的基本使用 了解Thymeleaf的基本使用 1. 了解SpringBoot在这一部分，我们主要了解以下3个问题： 什么是SpringBoot 为什么要学习SpringBoot SpringBoot的特点 1.1.什么是SpringBootSpringBoot是Spring项目中的一个子工程，与我们所熟知的Spring-framework 同属于spring的产品: 我们可以看到下面的一段介绍： Takes an opinionated view of building production-ready Spring applications. Spring Boot favors convention over configuration and is designed to get you up and running as quickly as possible. 翻译一下： 用一些固定的方式来构建生产级别的spring应用。Spring Boot 推崇约定大于配置的方式以便于你能够尽可能快速的启动并运行程序。 其实人们把Spring Boot 称为搭建程序的脚手架。其最主要作用就是帮我们快速的构建庞大的spring项目，并且尽可能的减少一切xml配置，做到开箱即用，迅速上手，让我们关注与业务而非配置。 1.2.为什么要学习SpringBootjava一直被人诟病的一点就是臃肿、麻烦。当我们还在辛苦的搭建项目时，可能Python程序员已经把功能写好了，究其原因主要是两点： 复杂的配置， 项目各种配置其实是开发时的损耗， 因为在思考 Spring 特性配置和解决业务问题之间需要进行思维切换，所以写配置挤占了写应用程序逻辑的时间。 一个是混乱的依赖管理。 项目的依赖管理也是件吃力不讨好的事情。决定项目里要用哪些库就已经够让人头痛的了，你还要知道这些库的哪个版本和其他库不会有冲突，这难题实在太棘手。并且，依赖管理也是一种损耗，添加依赖不是写应用程序代码。一旦选错了依赖的版本，随之而来的不兼容问题毫无疑问会是生产力杀手。 而SpringBoot让这一切成为过去！ Spring Boot 简化了基于Spring的应用开发，只需要“run”就能创建一个独立的、生产级别的Spring应用。Spring Boot为Spring平台及第三方库提供开箱即用的设置（提供默认设置，存放默认配置的包就是启动器），这样我们就可以简单的开始。多数Spring Boot应用只需要很少的Spring配置。 我们可以使用SpringBoot创建java应用，并使用java –jar 启动它，就能得到一个生产级别的web工程。 1.3.SpringBoot的特点Spring Boot 主要目标是： 为所有 Spring 的开发者提供一个非常快速的、广泛接受的入门体验 开箱即用（启动器starter-其实就是SpringBoot提供的一个jar包），但通过自己设置参数（.properties），即可快速摆脱这种方式。 提供了一些大型项目中常见的非功能性特性，如内嵌服务器、安全、指标，健康检测、外部化配置等 绝对没有代码生成，也无需 XML 配置。 更多细节，大家可以到官网查看。 2.快速入门接下来，我们就来利用SpringBoot搭建一个web工程，体会一下SpringBoot的魅力所在！ 2.1.创建工程我们先新建一个空的工程： 工程名为demo： 新建一个model： 使用maven来构建： 然后填写项目坐标： 目录结构： 项目结构： 2.2.添加依赖看到这里很多同学会有疑惑，前面说传统开发的问题之一就是依赖管理混乱，怎么这里我们还需要管理依赖呢？难道SpringBoot不帮我们管理吗？ 别着急，现在我们的项目与SpringBoot还没有什么关联。SpringBoot提供了一个名为spring-boot-starter-parent的工程，里面已经对各种常用依赖（并非全部）的版本进行了管理，我们的项目需要以这个项目为父工程，这样我们就不用操心依赖的版本问题了，需要什么依赖，直接引入坐标即可！ 2.2.1.添加父工程坐标12345&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.0.RELEASE&lt;/version&gt;&lt;/parent&gt; 2.2.2.添加web启动器为了让SpringBoot帮我们完成各种自动配置，我们必须引入SpringBoot提供的自动配置依赖，我们称为启动器。因为我们是web项目，这里我们引入web启动器： 123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 需要注意的是，我们并没有在这里指定版本信息。因为SpringBoot的父工程已经对版本进行了管理了。 这个时候，我们会发现项目中多出了大量的依赖： 这些都是SpringBoot根据spring-boot-starter-web这个依赖自动引入的，而且所有的版本都已经管理好，不会出现冲突。 2.2.3.管理jdk版本默认情况下，maven工程的jdk版本是1.5，而我们开发使用的是1.8，因此这里我们需要修改jdk版本，只需要简单的添加以下属性即可： 123&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt;&lt;/properties&gt; 2.2.4.完整pom123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.mall.demo&lt;/groupId&gt; &lt;artifactId&gt;springboot-demo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.0.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2.3.启动类Spring Boot项目通过main函数即可启动，我们需要创建一个启动类： 然后编写main函数： 123456@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 2.4.编写controller接下来，我们就可以像以前那样开发SpringMVC的项目了！ 我们编写一个controller： 代码： 12345678@RestControllerpublic class HelloController &#123; @GetMapping(\"hello\") public String hello()&#123; return \"hello, spring boot!\"; &#125;&#125; 2.5.启动测试接下来，我们运行main函数，查看控制台： 并且可以看到监听的端口信息： 1）监听的端口是8080 2）SpringMVC的映射路径是：/ 3）/hello路径已经映射到了HelloController中的hello()方法 打开页面访问：http://localhost:8080/hello 测试成功了！ 3.Java配置在入门案例中，我们没有任何的配置，就可以实现一个SpringMVC的项目了，快速、高效！ 但是有同学会有疑问，如果没有任何的xml，那么我们如果要配置一个Bean该怎么办？比如我们要配置一个数据库连接池，以前会这么玩： 1234567&lt;!-- 配置连接池 --&gt;&lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\" init-method=\"init\" destroy-method=\"close\"&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\" /&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\" /&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\" /&gt;&lt;/bean&gt; 现在该怎么做呢？ 3.1.回顾历史事实上，在Spring3.0开始，Spring官方就已经开始推荐使用java配置来代替传统的xml配置了，我们不妨来回顾一下Spring的历史： Spring1.0时代 在此时因为jdk1.5刚刚出来，注解开发并未盛行，因此一切Spring配置都是xml格式，想象一下所有的bean都用xml配置，细思极恐啊，心疼那个时候的程序员2秒 Spring2.0时代 Spring引入了注解开发，但是因为并不完善，因此并未完全替代xml，此时的程序员往往是把xml与注解进行结合，貌似我们之前都是这种方式。 Spring3.0及以后 3.0以后Spring的注解已经非常完善了，因此Spring推荐大家使用完全的java配置来代替以前的xml，不过似乎在国内并未推广盛行。然后当SpringBoot来临，人们才慢慢认识到java配置的优雅。 有句古话说的好：拥抱变化，拥抱未来。所以我们也应该顺应时代潮流，做时尚的弄潮儿，一起来学习下java配置的玩法。 3.2.尝试java配置java配置主要靠java类和一些注解，比较常用的注解有： @Configuration：声明一个类作为配置类，代替xml文件 @Bean：声明在方法上，将方法的返回值加入Bean容器，代替&lt;bean&gt;标签 @value：属性注入 @PropertySource：指定外部属性文件， 我们接下来用java配置来尝试实现连接池配置： 首先引入Druid连接池依赖： 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.6&lt;/version&gt;&lt;/dependency&gt; 然后引入mysql驱动依赖: 12345&lt;dependency&gt; &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt; &lt;version&gt;8.0.19&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; 创建一个jdbc.properties文件，编写jdbc属性： 1234jdbc.driverClassName=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://127.0.0.1:3306/mall?serverTimezone=UTCjdbc.username=rootjdbc.password=123 然后编写代码： 1234567891011121314151617181920212223@Configuration@PropertySource(\"classpath:jdbc.properties\")public class JdbcConfig &#123; @Value(\"$&#123;jdbc.url&#125;\") String url; @Value(\"$&#123;jdbc.driverClassName&#125;\") String driverClassName; @Value(\"$&#123;jdbc.username&#125;\") String username; @Value(\"$&#123;jdbc.password&#125;\") String password; @Bean public DataSource dataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setUrl(url); dataSource.setDriverClassName(driverClassName); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; &#125;&#125; 解读： @Configuration：声明我们JdbcConfig是一个配置类 @PropertySource：指定属性文件的路径是:classpath:jdbc.properties 通过@Value为属性注入值 通过@Bean将 dataSource()方法声明为一个注册Bean的方法，Spring会自动调用该方法，将方法的返回值加入Spring容器中。 然后我们就可以在任意位置通过@Autowired注入DataSource了！ 我们在HelloController中测试： 1234567891011@RestControllerpublic class HelloController &#123; @Autowired private DataSource dataSource; @GetMapping(\"hello\") public String hello() &#123; return \"hello, spring boot!\" + dataSource; &#125;&#125; 然后Debug运行并查看： 属性注入成功了！ 3.3.SpringBoot的属性注入在上面的案例中，我们实验了java配置方式。不过属性注入使用的是@Value注解。这种方式虽然可行，但是不够强大，因为它只能注入基本类型值。 在SpringBoot中，提供了一种新的属性注入方式，支持各种java基本数据类型及复杂类型的注入。 1）我们新建一个类，用来进行属性注入： 123456789@ConfigurationProperties(prefix = \"jdbc\")public class JdbcProperties &#123; private String url; private String driverClassName; private String username; private String password; // ... 略 // getters 和 setters&#125; 在类上通过@ConfigurationProperties注解声明当前类为属性读取类 prefix=&quot;jdbc&quot;读取属性文件中，前缀为jdbc的值。 在类上定义各个属性，名称必须与属性文件中jdbc.后面部分一致 需要注意的是，这里我们并没有指定属性文件的地址，所以我们需要把jdbc.properties名称改为application.properties，这是SpringBoot默认读取的属性文件名： 2）在JdbcConfig中使用这个属性： 1234567891011121314@Configuration@EnableConfigurationProperties(JdbcProperties.class)public class JdbcConfig &#123; @Bean public DataSource dataSource(JdbcProperties jdbc) &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setUrl(jdbc.getUrl()); dataSource.setDriverClassName(jdbc.getDriverClassName()); dataSource.setUsername(jdbc.getUsername()); dataSource.setPassword(jdbc.getPassword()); return dataSource; &#125;&#125; 通过@EnableConfigurationProperties(JdbcProperties.class)来声明要使用JdbcProperties这个类的对象 然后你可以通过以下方式注入JdbcProperties： @Autowired注入 12@Autowiredprivate JdbcProperties prop; 构造函数注入 1234private JdbcProperties prop;public JdbcConfig(Jdbcproperties prop)&#123; this.prop = prop;&#125; 声明有@Bean的方法参数注入 1234@Beanpublic Datasource dataSource(JdbcProperties prop)&#123; // ...&#125; 本例中，我们采用第三种方式。 3）测试结果： 大家会觉得这种方式似乎更麻烦了，事实上这种方式有更强大的功能，也是SpringBoot推荐的注入方式。两者对比关系： 优势： Relaxed binding：松散绑定 不严格要求属性文件中的属性名与成员变量名一致。支持驼峰，中划线，下划线等等转换，甚至支持对象引导。比如：user.friend.name：代表的是user对象中的friend属性中的name属性，显然friend也是对象。@value注解就难以完成这样的注入方式。 meta-data support：元数据支持，帮助IDE生成属性提示（写开源框架会用到）。 3.4、更优雅的注入事实上，如果一段属性只有一个Bean需要使用，我们无需将其注入到一个类（JdbcProperties）中。而是直接在需要的地方声明即可： 1234567891011@Configurationpublic class JdbcConfig &#123; @Bean // 声明要注入的属性前缀，SpringBoot会自动把相关属性通过set方法注入到DataSource中 @ConfigurationProperties(prefix = \"jdbc\") public DataSource dataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); return dataSource; &#125;&#125; 我们直接把@ConfigurationProperties(prefix = &quot;jdbc&quot;)声明在需要使用的@Bean的方法上，然后SpringBoot就会自动调用这个Bean（此处是DataSource）的set方法，然后完成注入。使用的前提是：该类必须有对应属性的set方法！ 我们将jdbc的url改成：/mall，再次测试： 4.自动配置原理使用SpringBoot之后，一个整合了SpringMVC的WEB工程开发，变的无比简单，那些繁杂的配置都消失不见了，这是如何做到的？ 一切魔力的开始，都是从我们的main函数来的，所以我们再次来看下启动类： 我们发现特别的地方有两个： 注解：@SpringBootApplication run方法：SpringApplication.run() 我们分别来研究这两个部分。 4.1.了解@SpringBootApplication点击进入，查看源码： 这里重点的注解有3个： @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan 4.1.1.@SpringBootConfiguration我们继续点击查看源码： 通过这段我们可以看出，在这个注解上面，又有一个@Configuration注解。通过上面的注释阅读我们知道：这个注解的作用就是声明当前类是一个配置类，然后Spring会自动扫描到添加了@Configuration的类，并且读取其中的配置信息。而@SpringBootConfiguration是来声明当前类是SpringBoot应用的配置类，项目中只能有一个。所以一般我们无需自己添加。 4.1.2.@EnableAutoConfiguration关于这个注解，官网上有一段说明： The second class-level annotation is @EnableAutoConfiguration. This annotationtells Spring Boot to “guess” how you want to configure Spring, based on the jardependencies that you have added. Since spring-boot-starter-web added Tomcatand Spring MVC, the auto-configuration assumes that you are developing a webapplication and sets up Spring accordingly. 简单翻译以下： 第二级的注解@EnableAutoConfiguration，告诉SpringBoot基于你所添加的依赖，去“猜测”你想要如何配置Spring。比如我们引入了spring-boot-starter-web，而这个启动器中帮我们添加了tomcat、SpringMVC的依赖。此时自动配置就知道你是要开发一个web应用，所以就帮你完成了web及SpringMVC的默认配置了！ 总结，SpringBoot内部对大量的第三方库或Spring内部库进行了默认配置，这些配置是否生效，取决于我们是否引入了对应库所需的依赖，如果有那么默认配置就会生效。 所以，我们使用SpringBoot构建一个项目，只需要引入所需框架的依赖，配置就可以交给SpringBoot处理了。除非你不希望使用SpringBoot的默认配置，它也提供了自定义配置的入口。 4.1.3.@ComponentScan我们跟进源码： 并没有看到什么特殊的地方。我们查看注释： 大概的意思： 配置组件扫描的指令。提供了类似与&lt;context:component-scan&gt;标签的作用 通过basePackageClasses或者basePackages属性来指定要扫描的包。如果没有指定这些属性，那么将从声明这个注解的类所在的包开始，扫描包及子包 而我们的@SpringBootApplication注解声明的类就是main函数所在的启动类，因此扫描的包是该类所在包及其子包。因此，一般启动类会放在一个比较前的包目录中。 4.2.默认配置原理4.2.1默认配置类通过刚才的学习，我们知道@EnableAutoConfiguration会开启SpringBoot的自动配置，并且根据你引入的依赖来生效对应的默认配置。那么问题来了： 这些默认配置是在哪里定义的呢？ 为何依赖引入就会触发配置呢？ 其实在我们的项目中，已经引入了一个依赖：spring-boot-autoconfigure，其中定义了大量自动配置类： 还有： 非常多，几乎涵盖了现在主流的开源框架，例如： redis jms amqp jdbc jackson mongodb jpa solr elasticsearch … 等等 我们来看一个我们熟悉的，例如SpringMVC，查看mvc 的自动配置类： 打开WebMvcAutoConfiguration： 我们看到这个类上的4个注解： @Configuration：声明这个类是一个配置类 @ConditionalOnWebApplication(type = Type.SERVLET) ConditionalOn，翻译就是在某个条件下，此处就是满足项目的类是是Type.SERVLET类型，也就是一个普通web工程，显然我们就是 @ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class }) 这里的条件是OnClass，也就是满足以下类存在：Servlet、DispatcherServlet、WebMvcConfigurer，其中Servlet只要引入了tomcat依赖自然会有，后两个需要引入SpringMVC才会有。这里就是判断你是否引入了相关依赖，引入依赖后该条件成立，当前类的配置才会生效！ @ConditionalOnMissingBean(WebMvcConfigurationSupport.class) 这个条件与上面不同，OnMissingBean，是说环境中没有指定的Bean这个才生效。其实这就是自定义配置的入口，也就是说，如果我们自己配置了一个WebMVCConfigurationSupport的类，那么这个默认配置就会失效！ 接着，我们查看该类中定义了什么： 视图解析器： 处理器适配器（HandlerAdapter）： 还有很多，这里就不一一截图了。 4.2.2.默认配置属性另外，这些默认配置的属性来自哪里呢？ 我们看到，这里通过@EnableAutoConfiguration注解引入了两个属性：WebMvcProperties和ResourceProperties。这不正是SpringBoot的属性注入玩法嘛。 我们查看这两个属性类： 找到了内部资源视图解析器的prefix和suffix属性。 ResourceProperties中主要定义了静态资源（.js,.html,.css等)的路径： 如果我们要覆盖这些默认属性，只需要在application.properties中定义与其前缀prefix和字段名一致的属性即可。 4.3.总结SpringBoot为我们提供了默认配置，而默认配置生效的条件一般有两个： 你引入了相关依赖 你自己没有配置 1）启动器 所以，我们如果不想配置，只需要引入依赖即可，而依赖版本我们也不用操心，因为只要引入了SpringBoot提供的stater（启动器），就会自动管理依赖及版本了。 因此，玩SpringBoot的第一件事情，就是找启动器，SpringBoot提供了大量的默认启动器 2）全局配置 另外，SpringBoot的默认配置，都会读取默认属性，而这些属性可以通过自定义application.properties文件来进行覆盖。这样虽然使用的还是默认配置，但是配置中的值改成了我们自定义的。 因此，玩SpringBoot的第二件事情，就是通过application.properties来覆盖默认属性值，形成自定义配置。 5.SpringBoot实践接下来，我们来看看如何用SpringBoot来玩转以前的SSM,我们沿用之前讲解SSM用到的数据库tb_user和实体类User 5.1.整合SpringMVC虽然默认配置已经可以使用SpringMVC了，不过我们有时候需要进行自定义配置。 5.1.1.修改端口查看SpringBoot的全局属性可知，端口通过以下方式配置： 12# 映射端口server.port=80 重启服务后测试： 5.1.2.访问静态资源现在，我们的项目是一个jar工程，那么就没有webapp，我们的静态资源该放哪里呢？ 回顾我们上面看的源码，有一个叫做ResourceProperties的类，里面就定义了静态资源的默认查找路径： 默认的静态资源路径为： classpath:/META-INF/resources/ classpath:/resources/ 对应目录为:src/main/java/resources/resources/ classpath:/static/ 对应目录为:src/main/java/resources/static/ classpath:/public/ 对应目录为:src/main/java/resources/public/ 只要静态资源放在这些目录中任何一个，SpringMVC都会帮我们处理。 我们习惯会把静态资源放在classpath:/static/目录下。我们创建目录，并且添加一些静态资源： 重启项目后测试： 5.1.3.添加拦截器拦截器也是我们经常需要使用的，在SpringBoot中该如何配置呢？ 拦截器不是一个普通属性，而是一个类，所以就要用到java配置方式了。在SpringBoot官方文档中有这么一段说明： If you want to keep Spring Boot MVC features and you want to add additional MVC configuration (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or ExceptionHandlerExceptionResolver, you can declare a WebMvcRegistrationsAdapter instance to provide such components. If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc. 翻译： 如果你想要保持Spring Boot 的一些默认MVC特征，同时又想自定义一些MVC配置（包括：拦截器，格式化器, 视图控制器、消息转换器 等等），你应该让一个类实现WebMvcConfigurer，并且添加@Configuration注解，但是千万不要加@EnableWebMvc注解。如果你想要自定义HandlerMapping、HandlerAdapter、ExceptionResolver等组件，你可以创建一个WebMvcRegistrationsAdapter实例 来提供以上组件。 如果你想要完全自定义SpringMVC，不保留SpringBoot提供的一切特征，你可以自己定义类并且添加@Configuration注解和@EnableWebMvc注解 总结：通过实现WebMvcConfigurer并添加@Configuration注解来实现自定义部分SpringMvc配置。 首先我们定义一个拦截器： 12345678910111213141516171819public class LoginInterceptor implements HandlerInterceptor &#123; private Logger logger = LoggerFactory.getLogger(LoginInterceptor.class); @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) &#123; logger.debug(\"preHandle method is now running!\"); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) &#123; logger.debug(\"postHandle method is now running!\"); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; logger.debug(\"afterCompletion method is now running!\"); &#125;&#125; 然后，我们定义配置类，注册拦截器： 123456789101112131415161718192021@Configurationpublic class MvcConfig implements WebMvcConfigurer&#123; /** * 通过@Bean注解，将我们定义的拦截器注册到Spring容器 * @return */ @Bean public LoginInterceptor loginInterceptor()&#123; return new LoginInterceptor(); &#125; /** * 重写接口中的addInterceptors方法，添加自定义拦截器 * @param registry */ @Override public void addInterceptors(InterceptorRegistry registry) &#123; // 通过registry来注册拦截器，通过addPathPatterns来添加拦截路径 registry.addInterceptor(this.loginInterceptor()).addPathPatterns(\"/**\"); &#125;&#125; 结构如下： 接下来运行并查看日志： 你会发现日志中什么都没有，因为我们记录的log级别是debug，默认是显示info以上，我们需要进行配置。 SpringBoot通过logging.level.*=debug来配置日志级别，*填写包名 12# 设置com.mall包的日志级别为debuglogging.level.com.mall=debug 再次运行查看： 1232018-05-05 17:50:01.811 DEBUG 4548 --- [p-nio-80-exec-1] com.mall.interceptor.LoginInterceptor : preHandle method is now running!2018-05-05 17:50:01.854 DEBUG 4548 --- [p-nio-80-exec-1] com.mall.interceptor.LoginInterceptor : postHandle method is now running!2018-05-05 17:50:01.854 DEBUG 4548 --- [p-nio-80-exec-1] com.mall.interceptor.LoginInterceptor : afterCompletion method is now running! 5.2.整合jdbc和事务spring中的jdbc连接和事务是配置中的重要一环，在SpringBoot中该如何处理呢？ 答案是不需要处理，我们只要找到SpringBoot提供的启动器即可： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt; 当然，不要忘了数据库驱动，SpringBoot并不知道我们用的什么数据库，这里我们选择MySQL： 1234&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; 至于事务，SpringBoot中通过注解来控制。就是我们熟知的@Transactional 123456789101112131415@Servicepublic class UserService &#123; @Autowired private UserMapper userMapper; public User queryById(Long id)&#123; return this.userMapper.selectByPrimaryKey(id); &#125; @Transactional public void deleteById(Long id)&#123; this.userMapper.deleteByPrimaryKey(id); &#125;&#125; 5.3.整合连接池其实，在刚才引入jdbc启动器的时候，SpringBoot已经自动帮我们引入了一个连接池： HikariCP应该是目前速度最快的连接池了，我们看看它与c3p0的对比： 因此，我们只需要指定连接池参数即可： 12345678910# 连接四大参数spring.datasource.url=jdbc:mysql://localhost:3306/mallspring.datasource.username=rootspring.datasource.password=123# 可省略，SpringBoot自动推断spring.datasource.driverClassName=com.mysql.jdbc.Driverspring.datasource.hikari.idle-timeout=60000spring.datasource.hikari.maximum-pool-size=30spring.datasource.hikari.minimum-idle=10 当然，如果你更喜欢Druid连接池，也可以使用Druid官方提供的启动器： 123456&lt;!-- Druid连接池 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt; 而连接信息的配置与上面是类似的，只不过在连接池特有属性上，方式略有不同： 12345678910#初始化连接数spring.datasource.druid.initial-size=1#最小空闲连接spring.datasource.druid.min-idle=1#最大活动连接spring.datasource.druid.max-active=20#获取连接时测试是否可用spring.datasource.druid.test-on-borrow=true#监控页面启动spring.datasource.druid.stat-view-servlet.allow=true 5.4.整合mybatis5.4.1.mybatisSpringBoot官方并没有提供Mybatis的启动器，不过Mybatis官网自己实现了： 123456&lt;!--mybatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; 配置，基本没有需要配置的： 1234# mybatis 别名扫描mybatis.type-aliases-package=com.mall.pojo# mapper.xml文件位置,如果没有映射文件，请注释掉mybatis.mapper-locations=classpath:mappers/*.xml 需要注意，这里没有配置mapper接口扫描包，因此我们需要给每一个Mapper接口添加@Mapper注解，才能被识别。 123@Mapperpublic interface UserMapper &#123;&#125; 5.4.2.通用mapper通用Mapper的作者也为自己的插件编写了启动器，我们直接引入即可： 123456&lt;!-- 通用mapper --&gt;&lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt;&lt;/dependency&gt; 不需要做任何配置就可以使用了。 123@Mapperpublic interface UserMapper extends tk.mybatis.mapper.common.Mapper&lt;User&gt;&#123;&#125; 5.5.启动测试将controller进行简单改造： 123456789101112@RestControllerpublic class HelloController &#123; @Autowired private UserService userService; @GetMapping(\"/hello\") public User hello() &#123; User user = this.userService.queryById(8L); return user; &#125;&#125; 我们启动项目，查看： 6.Thymeleaf快速入门SpringBoot并不推荐使用jsp，但是支持一些模板引擎技术： 我们今天的主角是Thymeleaf！ 6.1.为什么是Thymeleaf？简单说， Thymeleaf 是一个跟 Velocity、FreeMarker 类似的模板引擎，它可以完全替代 JSP 。相较与其他的模板引擎，它有如下三个极吸引人的特点： 动静结合：Thymeleaf 在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。这是由于它支持 html 原型，然后在 html 标签里增加额外的属性来达到模板+数据的展示方式。浏览器解释 html 时会忽略未定义的标签属性，所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。 开箱即用：它提供标准和spring标准两种方言，可以直接套用模板实现JSTL、 OGNL表达式效果，避免每天套模板、改jstl、改标签的困扰。同时开发人员也可以扩展和创建自定义的方言。 多方言支持：Thymeleaf 提供spring标准方言和一个与 SpringMVC 完美集成的可选模块，可以快速的实现表单绑定、属性编辑器、国际化等功能。 与SpringBoot完美整合，SpringBoot提供了Thymeleaf的默认配置，并且为Thymeleaf设置了视图解析器，我们可以像以前操作jsp一样来操作Thymeleaf。代码几乎没有任何区别，就是在模板语法上有区别。 接下来，我们就通过入门案例来体会Thymeleaf的魅力： 6.2.编写接口编写一个controller，返回一些用户数据，放入模型中，等会在页面渲染,Controller类上使用@Controller注解,不要使用@RestController 123456789@GetMapping(\"/all\")public String all(ModelMap model) &#123; // 查询用户 List&lt;User&gt; users = this.userService.queryAll(); // 放入模型 model.addAttribute(\"users\", users); // 返回模板名称（就是classpath:/templates/目录下的html文件名） return \"users\";&#125; 6.3.引入启动器直接引入启动器： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; SpringBoot会自动为Thymeleaf注册一个视图解析器： 与解析JSP的InternalViewResolver类似，Thymeleaf也会根据前缀和后缀来确定模板文件的位置： 默认前缀：classpath:/templates/ 默认后缀：.html 所以如果我们返回视图：users，会指向到 classpath:/templates/users.html 一般我们无需进行修改，默认即可。 6.4.静态页面根据上面的文档介绍，模板默认放在classpath下的templates文件夹，我们新建一个html文件放入其中： 编写html模板，渲染模型中的数据： 注意，把html 的名称空间，改成：xmlns:th=&quot;http://www.thymeleaf.org&quot; 会有语法提示 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;首页&lt;/title&gt; &lt;style type=\"text/css\"&gt; table &#123;border-collapse: collapse; font-size: 14px; width: 80%; margin: auto&#125; table, th, td &#123;border: 1px solid darkslategray;padding: 10px&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div style=\"text-align: center\"&gt; &lt;span style=\"color: darkslategray; font-size: 30px\"&gt;欢迎光临！&lt;/span&gt; &lt;hr/&gt; &lt;table class=\"list\"&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;用户名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;生日&lt;/th&gt; &lt;th&gt;备注&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each=\"user : $&#123;users&#125;\"&gt; &lt;td th:text=\"$&#123;user.id&#125;\"&gt;1&lt;/td&gt; &lt;td th:text=\"$&#123;user.name&#125;\"&gt;张三&lt;/td&gt; &lt;td th:text=\"$&#123;user.userName&#125;\"&gt;zhangsan&lt;/td&gt; &lt;td th:text=\"$&#123;user.age&#125;\"&gt;20&lt;/td&gt; &lt;td th:text=\"$&#123;user.sex&#125; == 1 ? '男': '女'\"&gt;男&lt;/td&gt; &lt;td th:text=\"$&#123;#dates.format(user.birthday, 'yyyy-MM-dd')&#125;\"&gt;1980-02-30&lt;/td&gt; &lt;td th:text=\"$&#123;user.note&#125;\"&gt;1&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 我们看到这里使用了以下语法： ${} ：这个类似与el表达式，但其实是ognl的语法，比el表达式更加强大 th-指令：th-是利用了Html5中的自定义属性来实现的。如果不支持H5，可以用data-th-来代替 th:each：类似于c:foreach 遍历集合，但是语法更加简洁 th:text：声明标签中的文本 例如&lt;td th-text=&#39;${user.id}&#39;&gt;1&lt;/td&gt;，如果user.id有值，会覆盖默认的1 如果没有值，则会显示td中默认的1。这正是thymeleaf能够动静结合的原因，模板解析失败不影响页面的显示效果，因为会显示默认值！ 6.5.测试接下来，我们打开页面测试一下： 6.6.模板缓存Thymeleaf会在第一次对模板解析之后进行缓存，极大的提高了并发处理能力。但是这给我们开发带来了不便，修改页面后并不会立刻看到效果，我们开发阶段可以关掉缓存使用： 12# 开发阶段关闭thymeleaf的模板缓存spring.thymeleaf.cache=false 注意： ​ 在Idea中，我们需要在修改页面后按快捷键：Ctrl + Shift + F9 对项目进行rebuild才可以。 ​ eclipse中没有测试过。 我们可以修改页面，测试一下。","categories":[],"tags":[{"name":"boot","slug":"boot","permalink":"http://yoursite.com/tags/boot/"}]},{"title":"es6第一天","slug":"Es6-1","date":"2020-05-13T15:02:04.000Z","updated":"2020-05-19T00:26:45.171Z","comments":true,"path":"2020/05/13/Es6-1/","link":"","permalink":"http://yoursite.com/2020/05/13/Es6-1/","excerpt":"","text":"","categories":[],"tags":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]}],"categories":[],"tags":[{"name":"centos7","slug":"centos7","permalink":"http://yoursite.com/tags/centos7/"},{"name":"测试","slug":"测试","permalink":"http://yoursite.com/tags/%E6%B5%8B%E8%AF%95/"},{"name":"boot","slug":"boot","permalink":"http://yoursite.com/tags/boot/"},{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]}